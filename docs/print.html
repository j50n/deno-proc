<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>proc</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Concepts</li><li class="spacer"></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">1.</strong> Stream Conversions</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">2.</strong> Transformers</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.</strong> The Zen of Errors</a></li><li class="chapter-item expanded affix "><li class="part-title">Minutia</li><li class="spacer"></li><li class="chapter-item expanded "><a href="spread.html"><strong aria-hidden="true">4.</strong> Using the Spread Operator in Run</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="spacer"></li><li class="chapter-item expanded "><a href="enumerable.html"><strong aria-hidden="true">5.</strong> Enumerable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="enumerate.html"><strong aria-hidden="true">5.1.</strong> enumerate (Factory)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> map</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> transform</div></li></ol></li><li class="chapter-item expanded "><a href="transformers.html"><strong aria-hidden="true">6.</strong> Transformers</a></li><li class="chapter-item expanded "><a href="utility.html"><strong aria-hidden="true">7.</strong> Utility Functions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">proc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="proc-02020"><a class="header" href="#proc-02020"><code>proc 0.20.20</code></a></h1>
<p><code>proc</code> is a powerful functional extension for <code>AsyncIterable</code> in Deno. It
supports managing external processes, provides extensions for concurrent
programming, and works seamlessly with <code>Deno</code> IO streams. With <code>proc</code>, writing
shell-style solutions in Deno is painless.</p>
<p><a href="https://deno.land/x/proc@0.20.20/mod3.ts" target="_blank">API
Documentation</a></p>
<h2 id="import"><a class="header" href="#import">Import</a></h2>
<p>Import using this path (note the use of <code>mod3.ts</code> rather than <code>mod.ts</code>).</p>
<pre><code class="language-typescript">import * as proc from &quot;https://deno.land/x/proc@0.20.20/mod3.ts&quot;;
</code></pre>
<h2 id="a-few-examples"><a class="header" href="#a-few-examples">A Few Examples</a></h2>
<p>These examples show some of the things <code>proc</code> can do.</p>
<h3 id="running-a-process"><a class="header" href="#running-a-process">Running a Process</a></h3>
<p>List the file names in the current directory (<code>-1</code> puts each on its own line),
capture as lines, and collect the names into an array.</p>
<pre><code class="language-typescript">const filesAndFolders = run(&quot;ls&quot;, &quot;-1&quot;, &quot;-a&quot;, &quot;.&quot;).lines.collect();
</code></pre>
<h3 id="chaining-processes-together"><a class="header" href="#chaining-processes-together">Chaining Processes Together</a></h3>
<p>Read &quot;War and Peace&quot; in from a compressed file. Uncompress the file. <code>grep</code> out
empty lines. Print it.</p>
<pre><code class="language-typescript">const warandpeace = resolve(&quot;./warandpeace.txt.gz&quot;);

read(warandpeace)
  .run(&quot;gunzip&quot;).
  .run(&quot;grep&quot;, &quot;-v&quot;, &quot;^$&quot;)
  .lines
  .forEach((line) =&gt; console.log(line));
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-sh">cat ./warandpeace.txt.gz | gunzip | grep -v '^$'
</code></pre>
<h3 id="functional-style"><a class="header" href="#functional-style">Functional Style</a></h3>
<p>For all even numbers between 1 and 100, multiply by 2 and print. So 4, 8, 12
... 200.</p>
<pre><code class="language-typescript">await range({ from: 1, until: 100 })
  .filter((n) =&gt; n % 2 === 0)
  .map((n) =&gt; n * 2)
  .forEach((n) =&gt; console.log(n));
</code></pre>
<h2 id="a-few-more-examples"><a class="header" href="#a-few-more-examples">A Few More Examples</a></h2>
<p>These examples are longer. More involved. Good stuff.</p>
<h3 id="working-with-multiple-copies-of-the-same-data"><a class="header" href="#working-with-multiple-copies-of-the-same-data">Working with Multiple Copies of the Same Data</a></h3>
<p>Read &quot;War and Peace&quot; and uncompress. Convert to lower case. Split into words.
Split into <code>A</code> and <code>B</code> enumerations.</p>
<p>With <code>A</code>, sort the words, find the unique words, and count them.</p>
<p>With <code>B</code>, just count the total number of words.</p>
<pre><code class="language-typescript">const warandpeace = resolve(&quot;./warandpeace.txt.gz&quot;);

const [wordsA, wordsB] = read(warandpeace)
  .run(&quot;gunzip&quot;).lines
  .map((line) =&gt; line.toLocaleLowerCase())
  .run(&quot;grep&quot;, &quot;-oE&quot;, &quot;(\\w|')+&quot;)
  .tee();

const [uniqueWords, totalWords] = await Promise.all([
  wordsA.run(&quot;sort&quot;).run(&quot;uniq&quot;).run(&quot;wc&quot;, &quot;-l&quot;).lines
    .map((n) =&gt; parseInt(n, 10))
    .first,
  wordsB.run(&quot;wc&quot;, &quot;-l&quot;).lines
    .map((n) =&gt; parseInt(n, 10))
    .first,
]);

console.log(`Total: ${totalWords.toLocaleString()}`);
console.log(`Unique: ${uniqueWords.toLocaleString()}`);
</code></pre>
<p>This is (<em>almost</em>) equivalent to:</p>
<pre><code class="language-sh"># Count unique words
cat ./warandpeace.txt.gz \
  | gunzip \
  | tr '[:upper:]' '[:lower:]' \
  | grep -oE &quot;(\\w|')+&quot; \
  | sort \
  | uniq \
  | wc -l 

# Count all words
cat ./warandpeace.txt.gz \
  | gunzip \
  | tr '[:upper:]' '[:lower:]' \
  | grep -oE &quot;(\\w|')+&quot; \
  | wc -l
</code></pre>
<h3 id="concurrent-total-used-storage-for-s3-buckets"><a class="header" href="#concurrent-total-used-storage-for-s3-buckets">Concurrent Total Used Storage for S3 Buckets</a></h3>
<p><code>proc</code> supports concurrent operations with controlled (limited) concurrency.
This is a way to run child processes in parallel without swamping your server.</p>
<p>If you have to work with S3 buckets, you know it is time consuming to determine
how much storage space you are using/paying for, and where you are using the
most storage. <code>proc</code> makes it possible to run <code>ls --summarize</code> with parallelism
matching the number of CPU cores available (or whatever concurrency you
specify). The specific methods that support concurrent operations are
<code>.concurrentMap()</code> and <code>.concurrentUnorderedMap()</code>.</p>
<p>To list the <code>s3</code> buckets in your AWS account from terminal:</p>
<pre><code class="language-sh">aws s3 ls
</code></pre>
<p>The result looks something like this:</p>
<pre><code>2013-07-11 17:08:50 mybucket
2013-07-24 14:55:44 mybucket2
</code></pre>
<p>Grab those bucket names with <code>proc</code>:</p>
<pre><code class="language-typescript">const buckets = await run(&quot;aws&quot;, &quot;s3&quot;, &quot;ls&quot;)
  .map((b) =&gt; b.split(/\s+/g, 3))
  .map((b) =&gt; b[b.length - 1])
  .collect();
</code></pre>
<p>To get the total storage size in bytes from terminal:</p>
<pre><code class="language-sh">aws s3 ls s3://mybucket --recursive --summarize
</code></pre>
<p>This will list all objects in the bucket, but we can ignore that noise. At the
end of the operation, we are looking for a line that looks like this:</p>
<pre><code>Total Size: 2.9 MiB
</code></pre>
<p>This is potentially a long-running operation (some buckets have a lot of
objects), so we want to run it concurrently. With <code>proc</code>:</p>
<pre><code class="language-typescript">enumerate(buckets).concurrentUnorderedMap(
  async (bucket) =&gt; {
    const answer: string = await run(
        &quot;nice&quot;, &quot;-19&quot;,
        &quot;aws&quot;, &quot;s3&quot;, &quot;ls&quot;, 
        `s3://${bucket}`, 
        &quot;--recursive&quot;, &quot;--summarize&quot;)
      .filter(line =&gt; line.includes(&quot;Total Size:&quot;))
      .map(line =&gt; line.trim())
      .first;

    return {bucket, answer};
  }.forEach(({bucket, answer}) =&gt; console.log(`${bucket}\t${answer}`))
)
</code></pre>
<p>Use <code>nice</code> because <em>this will eat your server otherwise.</em> The method
<code>.concurrentUnorderedMap()</code> will, by default, run one process for each CPU
available concurrently until all work is done.</p>
<p>The result will look something like this:</p>
<pre><code>mybucket  Total Size: 2.9 MiB
mybucket2 Total Size: 30.2 MiB
</code></pre>
<h2 id="odd-ducks"><a class="header" href="#odd-ducks">Odd Ducks</a></h2>
<p>Other useful stuff. These might be a little off topic for this library, but here
they are.</p>
<h3 id="a-lazy-way-to-count"><a class="header" href="#a-lazy-way-to-count">A Lazy Way to Count</a></h3>
<p>Print the numbers from 0 to 99.</p>
<pre><code class="language-typescript">for await (const i of range({ to: 100 })) {
  console.log(i);
}
</code></pre>
<h3 id="sleep"><a class="header" href="#sleep">Sleep</a></h3>
<p>A convenient way to wait a little bit. This pauses for 1 second.</p>
<pre><code class="language-typescript">await sleep(1000);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream-conversions"><a class="header" href="#stream-conversions">Stream Conversions</a></h1>
<p>Deno has methods to convert between <code>AsyncIterable</code> and streams as well as
readers and writers at
<a href="https://deno.land/std/streams/mod.ts">https://deno.land/std/streams/mod.ts</a>.
These libraries have moved around quite a bit so they can be difficult to search
for.</p>
<p><em>Note that error propagation through streams in Deno is somewhere between tricky
and broken.</em> Be sure to test your code thoroughly for error handling if you need
to convert to and use streams API.</p>
<h2 id="asynciterable-to-stream"><a class="header" href="#asynciterable-to-stream"><code>AsyncIterable</code> to <code>Stream</code></a></h2>
<p>To convert from an <code>AsyncIterable</code> (or <code>Enumerable</code>) to a <code>ReadableStream</code>, use
the
<a href="https://deno.land/std/streams/mod.ts?s=readableStreamFromIterable">readableStreamFromIterable</a>
function.</p>
<h2 id="stream-to-asynciterable"><a class="header" href="#stream-to-asynciterable"><code>Stream</code> to <code>AsyncIterable</code></a></h2>
<p>A <code>ReadableStream</code> is an <code>AsyncIterable</code>. Avoid the use of <code>.pipeThrough()</code> and
<code>.pipeTo()</code>. Use <code>for await</code> or <code>enumerate()</code> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transformers"><a class="header" href="#transformers">Transformers</a></h2>
<p>A transformer is just a function with this signature:</p>
<pre><code class="language-typescript">((it: AsyncIterable&lt;T&gt;) =&gt; AsyncIterable&lt;U&gt;);
</code></pre>
<p>A transformer transforms objects from one type to another. The chief difference
between this and a <code>map</code> operation is that you control the whole transformation,
so you can catch and throw errors emanating from the iteration and manage state.</p>
<p>You can easily create a transformer using an asynchronous generator. This one
will transform strings to lower-case:</p>
<pre><code class="language-typescript">async function* toLower(texts: AsyncIterable&lt;string&gt;) {
  for await (const text of texts) {
    yield text.toLocaleLowerCase();
  }
}
</code></pre>
<p>Here is an example:</p>
<pre><code class="language-typescript">const lowered = await enumerable([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])
  .transform(toLower)
  .collect();

assertEquals(lowered, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;Transformed to lower-case.&quot;);
</code></pre>
<p>The <code>transform</code> operation is analogous to <code>pipeThrough</code> in the streaming API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-zen-of-errors"><a class="header" href="#the-zen-of-errors">The Zen of Errors</a></h1>
<p>Error handling should just work. You should not have to check the exit code of
every process. Errors that occur upstream should flow downstream. You should not
have to manually <code>close</code> stuff.</p>
<p>This stuff should not be so complicated.</p>
<h2 id="tldr"><a class="header" href="#tldr">TLDR</a></h2>
<p>For the most part, you should just be able to use <code>proc</code> as is, letting most
errors bubble up, catching and handling errors when needed. Errors work the way
you would expect them to.</p>
<h2 id="the-process-perspective"><a class="header" href="#the-process-perspective">The Process Perspective</a></h2>
<p>If everything goes well, a process will read something from <code>stdin</code>, process it,
and write something to <code>stdout</code>. This will continue until <code>stdin</code> is exhausted.
At that point, the process with exit with code <code>0</code>.</p>
<p>If an error occurs, the process stops reading from <code>stdin</code> and exits with a
non-<code>0</code> error code.</p>
<h2 id="streaming-and-propagating-errors"><a class="header" href="#streaming-and-propagating-errors">Streaming and Propagating Errors</a></h2>
<p>Process <code>stdin</code>, <code>stdout</code>, and exit code match up well with asynchronous
iteration in Typescript. In general, <code>proc</code> attempts to process all of <code>stdout</code>
before checking for an exit code error, and it forwards errors that originate at
the input.</p>
<p>If a process has a non-zero <code>code</code>, an <code>ExitCodeError</code> is thrown. For a signal,
a <code>SignalError</code> is thrown. Errors are wrapped in a <code>SteamError</code> as they
propagate through a process in order to preserve the stack traces.</p>
<p>In short, it works pretty much as you would expect.</p>
<h2 id="an-example"><a class="header" href="#an-example">An Example</a></h2>
<p>In <code>bash</code>:</p>
<pre><code class="language-shell">cat ./warandpeace.txt.gz | grep -v '^$' | head -n 100
</code></pre>
<p>In <code>Typescript</code>:</p>
<pre><code class="language-typescript">await enumerable(file.readable)
  .run(&quot;gunzip&quot;)
  .run(&quot;grep&quot;, &quot;-v&quot;, &quot;^$&quot;)
  .run(&quot;head&quot;, &quot;-n&quot;, &quot;100&quot;)
  .transform(toLines)
  .flatten()
  .forEach((line) =&gt; console.log(line));
</code></pre>
<p>Errors flow from process input to process output. <code>stderr</code> is redirected to
process <code>stderr</code>.</p>
<div><!-- Generated by graphviz version 2.43.0 (0)
 --><!-- Title: finite_state_machine Pages: 1 --><svg width="432pt" height="144pt"
 viewBox="0.00 0.00 431.99 143.70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 139.7)"><title>finite_state_machine</title><polygon fill="white" stroke="transparent" points="-4,4 -4,-139.7 427.99,-139.7 427.99,4 -4,4"/><g id="clust1" class="cluster"><title>cluster_shell</title><polygon fill="lightgrey" stroke="lightgrey" points="75,-64.7 75,-116.7 336,-116.7 336,-64.7 75,-64.7"/></g><!-- A --><g id="node1" class="node"><title>A</title><polygon fill="none" stroke="black" points="148,-108.7 83,-108.7 83,-72.7 148,-72.7 148,-108.7"/><text text-anchor="middle" x="115.5" y="-87" font-family="Times,serif" font-size="14.00">gunzip</text></g><!-- B --><g id="node2" class="node"><title>B</title><polygon fill="none" stroke="black" points="238,-108.7 184,-108.7 184,-72.7 238,-72.7 238,-108.7"/><text text-anchor="middle" x="211" y="-87" font-family="Times,serif" font-size="14.00">grep</text></g><!-- A&#45;&gt;B --><g id="edge5" class="edge"><title>A&#45;&gt;B</title><path fill="none" stroke="black" d="M148.15,-90.7C156.44,-90.7 165.43,-90.7 173.93,-90.7"/><polygon fill="black" stroke="black" points="173.97,-94.2 183.97,-90.7 173.97,-87.2 173.97,-94.2"/></g><!-- err --><g id="node5" class="node"><title>err</title><ellipse fill="none" stroke="black" cx="393.99" cy="-28.7" rx="24.87" ry="24.87"/><ellipse fill="none" stroke="black" cx="393.99" cy="-28.7" rx="28.9" ry="28.9"/><text text-anchor="middle" x="393.99" y="-25" font-family="Times,serif" font-size="14.00">err</text></g><!-- A&#45;&gt;err --><g id="edge1" class="edge"><title>A:s&#45;&gt;err</title><path fill="none" stroke="red" d="M115.5,-72.7C115.5,-72.7 278.8,-46.9 355.31,-34.81"/><polygon fill="red" stroke="red" points="356.17,-38.22 365.5,-33.2 355.08,-31.3 356.17,-38.22"/></g><!-- C --><g id="node3" class="node"><title>C</title><polygon fill="none" stroke="black" points="328,-108.7 274,-108.7 274,-72.7 328,-72.7 328,-108.7"/><text text-anchor="middle" x="301" y="-87" font-family="Times,serif" font-size="14.00">head</text></g><!-- B&#45;&gt;C --><g id="edge6" class="edge"><title>B&#45;&gt;C</title><path fill="none" stroke="black" d="M238.4,-90.7C246.39,-90.7 255.31,-90.7 263.82,-90.7"/><polygon fill="black" stroke="black" points="263.92,-94.2 273.92,-90.7 263.92,-87.2 263.92,-94.2"/></g><!-- B&#45;&gt;err --><g id="edge2" class="edge"><title>B:s&#45;&gt;err</title><path fill="none" stroke="red" d="M211,-72.7C211,-72.7 302.32,-50.74 355.94,-37.85"/><polygon fill="red" stroke="red" points="356.9,-41.22 365.8,-35.48 355.26,-34.41 356.9,-41.22"/></g><!-- C&#45;&gt;err --><g id="edge3" class="edge"><title>C:s&#45;&gt;err</title><path fill="none" stroke="red" d="M301,-71.7C301,-71.7 332.05,-57.18 358.07,-45.02"/><polygon fill="red" stroke="red" points="359.79,-48.08 367.37,-40.68 356.83,-41.74 359.79,-48.08"/></g><!-- out --><g id="node6" class="node"><title>out</title><ellipse fill="none" stroke="black" cx="393.99" cy="-105.7" rx="26" ry="26"/><ellipse fill="none" stroke="black" cx="393.99" cy="-105.7" rx="30" ry="30"/><text text-anchor="middle" x="393.99" y="-102" font-family="Times,serif" font-size="14.00">out</text></g><!-- C&#45;&gt;out --><g id="edge7" class="edge"><title>C&#45;&gt;out</title><path fill="none" stroke="black" d="M328.32,-95.04C336.39,-96.37 345.45,-97.86 354.18,-99.3"/><polygon fill="black" stroke="black" points="353.75,-102.78 364.18,-100.95 354.89,-95.87 353.75,-102.78"/></g><!-- in --><g id="node4" class="node"><title>in</title><ellipse fill="none" stroke="black" cx="23.5" cy="-90.7" rx="19.5" ry="19.5"/><ellipse fill="none" stroke="black" cx="23.5" cy="-90.7" rx="23.5" ry="23.5"/><text text-anchor="middle" x="23.5" y="-87" font-family="Times,serif" font-size="14.00">in</text></g><!-- in&#45;&gt;A --><g id="edge4" class="edge"><title>in&#45;&gt;A</title><path fill="none" stroke="black" d="M47.21,-90.7C54.99,-90.7 63.97,-90.7 72.78,-90.7"/><polygon fill="black" stroke="black" points="72.96,-94.2 82.96,-90.7 72.96,-87.2 72.96,-94.2"/></g></g></svg></div>
<p>Uncompress a file. Remove all the lines that are empty. Take the first 100
lines.</p>
<p>Assume there is an error in the data that causes <code>gunzip</code> to fail at some point.</p>
<h3 id="scenario-1-a-data-error-in-the-first-100-lines"><a class="header" href="#scenario-1-a-data-error-in-the-first-100-lines">Scenario 1: A Data Error in the First 100 Lines</a></h3>
<p><em>There is an error early in the compressed data.</em></p>
<p><code>gunzip</code> will decompress data in chunks and write the result to <code>stdout</code> as it
goes. When it reaches the error, it will exit with a non-zero <code>code</code>.</p>
<p>Once the (partial) output from <code>gunzip</code> has been fully read, <code>proc</code> will check
the <code>code</code> and throw an error. This will be propagated forward through the input
of <code>head</code>, and then forward again through the input of <code>grep</code> as the output of
each is exhausted.</p>
<p>Note that it is also possible that bad data in results in invalid data coming
out, and since we process all the output data before we get the error, we might
see the data error first.</p>
<h3 id="scenario-2-a-data-error-after-the-first-100-lines"><a class="header" href="#scenario-2-a-data-error-after-the-first-100-lines">Scenario 2: A Data Error After the First 100 Lines</a></h3>
<p><em>There is an error later in the compressed data.</em></p>
<p>Once we get to line 100, <code>head</code> is done. It shuts down its input stream and
exits normally. Even if <code>gunzip</code> is unlucky enough to process the error data,
<code>head</code> is already done and success propagated forward. The error from <code>gunzip</code>
won't be able to propagate. Of course, if the error is <em>much</em> later in the data,
it will never even be read. Once <code>head</code> has found 100 lines, it shuts down its
input, which in turn shuts down <code>gunzip</code>. The error never happens in the first
place.</p>
<p>In other words, upstream processes may continue to function for a short time
after the downstream processes have exited, assuming the downstream processes
don't need to process input fully. In most cases this should not matter. If an
upstream process has side effects, though, weird things could happen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-spread-operator-in-run"><a class="header" href="#using-the-spread-operator-in-run">Using the Spread Operator in Run</a></h1>
<p>This is fine:</p>
<pre><code class="language-typescript">run(&quot;ls&quot;, &quot;-la&quot;);
</code></pre>
<p>The next example results in an error: <em>A spread argument must either have a
tuple type or be passed to a rest parameter.</em></p>
<pre><code class="language-typescript">run(...[&quot;ls&quot;, &quot;-la&quot;]); //Broken!
</code></pre>
<p>What gives?</p>
<p>Typescript needs a specific tuple type here, but assumes an array type instead.
<em>This is a Typescript thing,</em> and I am sure they will get around to fixing it
one day.</p>
<p>Here is the longer version. The <em>rest</em> parameter passed to <code>run</code> is a tuple of
type <code>Cmd</code>. The type signature is <code>[string|URL, ...string[]]</code>. Typescript
assumes that <code>[&quot;ls&quot;, &quot;-la&quot;]</code> is of type <code>string[]</code> and must be told otherwise.
It is not able to figure out that <code>string[]</code> of guaranteed non-zero length is
compatible with the tuple type <code>Cmd</code>.</p>
<p>Until Typescript addresses this issue, the idiomatic fix is to simply specify
the tuple type:</p>
<pre><code class="language-typescript">run(...[&quot;ls&quot;, &quot;-la&quot;] as Cmd);
</code></pre>
<p>This is a practical exmple of building up a command in piecemeal fashion. It
seems a little cleaner to specify the type where you create the tuple:</p>
<pre><code class="language-typescript">const cmd: Cmd = [&quot;ls&quot;];
cmd.push(&quot;-la&quot;);

run(...cmd);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerable"><a class="header" href="#enumerable">Enumerable</a></h1>
<p>See
<a href="https://github.com/j50n/deno-proc/blob/main/src/enumerable.ts">enumerable.ts</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerate"><a class="header" href="#enumerate">enumerate</a></h1>
<p>Create a new <code>Enumerable</code> with the <code>enumerate</code> factory method.</p>
<p>This can wrap another <code>AsyncIterable</code> or an <code>Iterable</code>. Passing <code>null</code> results
in an empty enumeration.</p>
<blockquote>
<p>⚠️ Use the <code>enumerate</code> method rather than creating a <code>new Enumerable()</code>
directly.</p>
</blockquote>
<h3 id="example-1"><a class="header" href="#example-1">Example 1</a></h3>
<p>Use <code>enumerate</code> to turn an array of numbers into an <code>AsyncIterable</code>.</p>
<pre><code class="language-typescript">await enumerate([1, 2, 3]).map((n) =&gt; n * 2).collect();

// [2, 4, 6]
</code></pre>
<h3 id="example-2"><a class="header" href="#example-2">Example 2</a></h3>
<p>Open a file. Use <code>enumerate</code> to wrap the <code>ReadableStream</code> from the file into an
<code>Enumerable</code>. Uncompress, strip out empty lines, and count them. Convert the
output from <code>wc -l</code> into a number.</p>
<pre><code class="language-typescript">const file = await Deno.open(
  fromFileUrl(import.meta.resolve(&quot;./warandpeace.txt.gz&quot;)),
);

const count = await enumerate(file.readable)
  .run(&quot;gunzip&quot;)
  .run(&quot;grep&quot;, &quot;\S&quot;)
  .run(&quot;wc&quot;, &quot;-l&quot;)
  .lines
  .map((n) =&gt; parseInt(n, 10))
  .first;

console.log(count);

// 2102
</code></pre>
<p>We can make this a little bit shorter using the <code>read</code> method (which wraps
<code>enumerate</code>).</p>
<pre><code class="language-typescript">const count = await read(
  fromFileUrl(import.meta.resolve(&quot;./warandpeace.txt.gz&quot;)),
)
  .run(&quot;gunzip&quot;)
  .run(&quot;grep&quot;, &quot;\S&quot;)
  .run(&quot;wc&quot;, &quot;-l&quot;)
  .lines
  .map((n) =&gt; parseInt(n, 10))
  .first;

console.log(count);

// 2102
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transformers-1"><a class="header" href="#transformers-1">Transformers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h1>
<h2 id="sleep-1"><a class="header" href="#sleep-1">Sleep</a></h2>
<p>Pause for some amount of time (measured in milliseconds) without blocking.</p>
<p><strong>Example</strong></p>
<p>Sleep for two seconds:</p>
<pre><code class="language-typescript">await sleep(2000);
</code></pre>
<h2 id="range"><a class="header" href="#range">Range</a></h2>
<p>This lazily produces a sequence of numbers in <code>for...next</code> fashion.</p>
<p>There are two variants. In the <code>to</code> variant, the end number is exclusive. In the
<code>until</code> variant, the end number is inclusive. The default starting number is
always 0, and the default step is 1.</p>
<p>This is a lazy operation. It is creating the results one at a time rather than
all at once in memory. Therefore it is perfectly reasonable to do something like
create an infinite range.</p>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example 1</a></h3>
<p>Prints the numbers <code>0</code>, <code>1</code>, and <code>2</code>. Using <code>to</code> so the end number is exclusive.
Default <code>from</code> is <code>0</code>.</p>
<pre><code class="language-typescript">for (const i of range({ to: 3 })) {
  console.log(i);
}
</code></pre>
<h3 id="example-2-1"><a class="header" href="#example-2-1">Example 2</a></h3>
<p>Prints the numbers <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>. Using <code>from</code> so the end number is
inclusive. Default <code>from</code> is <code>0</code>.</p>
<pre><code class="language-typescript">for (const i of range({ until: 3 })) {
  console.log(i);
}
</code></pre>
<h3 id="example-3"><a class="header" href="#example-3">Example 3</a></h3>
<p>Prints the numbers from <code>10</code> to <code>1</code>, descending order.</p>
<pre><code class="language-typescript">for (const i of range({ from: 10, to: 0, step: -1 })) {
  console.log(i);
}
</code></pre>
<h3 id="example-4"><a class="header" href="#example-4">Example 4</a></h3>
<p>Prints the numbers from <code>0</code> to <code>99</code>.</p>
<pre><code class="language-typescript">for (const i of range({ to: 10 })) {
  for (const j of range({ to: 10 })) {
    console.log(i * 10 + j);
  }
}
</code></pre>
<h3 id="example-5"><a class="header" href="#example-5">Example 5</a></h3>
<p>An infinite loop that breaks at 20.</p>
<pre><code class="language-typescript">for await (const n of range({ to: Number.POSITIVE_INFINITY })) {
  if (n &gt; 20) {
    break;
  }
  console.log(n);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
