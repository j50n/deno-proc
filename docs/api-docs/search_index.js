(function () {
  window.DENO_DOC_SEARCH_INDEX = {"kind":"search","nodes":[{"id":"namespace_ByteSink","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"ByteSink","file":".","doc":"Conditional type for Enumerable.toStdout.","url":"././~/ByteSink.html","deprecated":false},{"id":"namespace_ChunkedLines","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"ChunkedLines","file":".","doc":"Conditional type for Enumerable.chunkedLines.","url":"././~/ChunkedLines.html","deprecated":false},{"id":"namespace_Cmd","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Cmd","file":".","doc":"Command signature: program name/path followed by arguments.","url":"././~/Cmd.html","deprecated":false},{"id":"namespace_ConcurrentOptions","kind":[{"char":"I","kind":"Interface","title":"Interface"}],"name":"ConcurrentOptions","file":".","doc":"Options for Enumerable.concurrentMap and Enumerable.concurrentUnorderedMap.","url":"././~/ConcurrentOptions.html","deprecated":false},{"id":"namespace_ConcurrentOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ConcurrentOptions.concurrency","file":".","doc":"Maximum concurrency.","url":"././~/ConcurrentOptions.concurrency.html","deprecated":false},{"id":"namespace_DAYS","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"DAYS","file":".","doc":"The number of milliseconds in a day.","url":"././~/DAYS.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"Enumerable","file":".","doc":"Fluent wrapper for AsyncIterable with composable operations.Enumerable provides a rich set of operations for working with async data streams:Transformations: map, filter, flatMapAggregations: reduce, count, collectUtilities: take, drop, concat, zipProcess integration: run, lines, toStdoutConcurrency: concurrentMap, concurrentUnorderedMapCreate instances using enumerate, not the constructor directly.","url":"././~/Enumerable.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.[Symbol.asyncIterator]","file":".","doc":"Implement AsyncIterable<T>.","url":"././~/Enumerable.prototype.[Symbol.asyncIterator].html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.enum","file":".","doc":"Adds a counter from 0 to n-1 of the items being enumerated.Returns tuples of [item, index] where index starts at 0.","url":"././~/Enumerable.prototype.enum.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.writeTo","file":".","doc":"Write all data to the writer.ExampleWrite some numbers to stdout.","url":"././~/Enumerable.prototype.writeTo.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.transform","file":".","doc":"Transform the iterable from one type to another with an opportunity to catch and handle errors.","url":"././~/Enumerable.prototype.transform.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.map","file":".","doc":"Map the iterator from one type to another.","url":"././~/Enumerable.prototype.map.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.flatten","file":".","doc":"Flatten the iterable.","url":"././~/Enumerable.prototype.flatten.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.flatMap","file":".","doc":"Map each item to an iterable and flatten the results.Equivalent to calling map() followed by flatten().","url":"././~/Enumerable.prototype.flatMap.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.concurrentMap","file":".","doc":"Map the sequence from one type to another, concurrently.Results are returned in order. The order of processing is concurrent, and therefore somewhat arbitrary.","url":"././~/Enumerable.prototype.concurrentMap.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.concurrentUnorderedMap","file":".","doc":"Map the sequence from one type to another, concurrently.Items are iterated out of order. This allows maximum concurrency at all times, but the output order cannot be assumed to be the same as the input order.This guarantees maximum concurrency whereas concurrentMap does not if the workload isn't balanced. Prefer concurrentUnorderedMap to concurrentMap for best/consistent performance.","url":"././~/Enumerable.prototype.concurrentUnorderedMap.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.filter","file":".","doc":"Keep only items that pass a test.","url":"././~/Enumerable.prototype.filter.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.find","file":".","doc":"Find the first item that matches a condition.","url":"././~/Enumerable.prototype.find.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.every","file":".","doc":"Test if every item satisfies a condition.","url":"././~/Enumerable.prototype.every.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.some","file":".","doc":"Test if any item satisfies a condition.","url":"././~/Enumerable.prototype.some.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.count","file":".","doc":"Count the number of items; optionally with a filter.","url":"././~/Enumerable.prototype.count.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.filterNot","file":".","doc":"Filter the sequence to exclude the items that pass a test. This returns the inverse of filter.","url":"././~/Enumerable.prototype.filterNot.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.reduce","file":".","doc":"Reduce the sequence to a single value.Executes a reducer function on each element, passing the accumulated result from one element to the next.","url":"././~/Enumerable.prototype.reduce.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.reduce","file":".","doc":"Reduce the sequence to a single value with an initial value.","url":"././~/Enumerable.prototype.reduce.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.reduce","file":".","doc":"","url":"././~/Enumerable.prototype.reduce.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.forEach","file":".","doc":"Perform an operation for each item in the sequence.","url":"././~/Enumerable.prototype.forEach.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.collect","file":".","doc":"Collect all items from this async iterable into an array.This consumes the entire iterable and returns a Promise that resolves to an array containing all items.","url":"././~/Enumerable.prototype.collect.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.run","file":".","doc":"Run a process, piping this iterable's output to its stdin.This allows chaining processes together like shell pipes. The current iterable's data is written to the new process's stdin, and the new process's stdout becomes the new iterable.","url":"././~/Enumerable.prototype.run.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.run","file":".","doc":"Run a process.","url":"././~/Enumerable.prototype.run.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.run","file":".","doc":"","url":"././~/Enumerable.prototype.run.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.tee","file":".","doc":"Split the sequence into multiple identical streams.Useful when you need to process the same data in different ways. Uses buffering internally, so be mindful of memory with large datasets.","url":"././~/Enumerable.prototype.tee.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.take","file":".","doc":"Take the first n items from the sequence.","url":"././~/Enumerable.prototype.take.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.first","file":".","doc":"Get the first item in the sequence.Consumes the enumeration and returns the first element.","url":"././~/Enumerable.prototype.first.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.drop","file":".","doc":"Skip the first n items and return the rest.","url":"././~/Enumerable.prototype.drop.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.concat","file":".","doc":"Concatenate this sequence with another.","url":"././~/Enumerable.prototype.concat.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.zip","file":".","doc":"Zip two Enumerables together. If collections are unequal length, the longer collection is truncated.Example","url":"././~/Enumerable.prototype.zip.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.unzip","file":".","doc":"Unzip a collection of [A, B] into Enumerable<A> and Enumerable<B>.Note that this operations uses tee, so it will use memory during the iteration.Example","url":"././~/Enumerable.prototype.unzip.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.lines","file":".","doc":"Convert byte stream to text lines.Important: This is a property, not a method. Use .lines not .lines().Returns an Enumerable where each item is a line of text. Lines are split on \\n or \\r\\n. Line endings are not included in the output.Note that this should probably only be used with small data. Consider chunkedLines to improve performance with larger data.","url":"././~/Enumerable.prototype.lines.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.chunkedLines","file":".","doc":"Convert to text lines, grouped into arrays.For large data or data that is broken into many small lines, this can improve performance over lines.","url":"././~/Enumerable.prototype.chunkedLines.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.toStdout","file":".","doc":"Dump output to stdout. Non-locking.","url":"././~/Enumerable.prototype.toStdout.html","deprecated":false},{"id":"namespace_Enumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Enumerable.prototype.writeBytesTo","file":".","doc":"Dump output to a writer and close it.This is a low-level asynchronous write of bytes without locking.","url":"././~/Enumerable.prototype.writeBytesTo.html","deprecated":false},{"id":"namespace_ErrorHandler","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"ErrorHandler","file":".","doc":"Optionally change or suppress the error before it is thrown. Note that this will only be called if either one or both of error and stderrData is defined (non-null).This is a chance to throw a custom error or to suppress throwing an error. You can pass any type of data from the stderr handler to the error handler since you own both functions.Throw the error you want to be thrown from the process. If you want to suppress the error, just don't throw an error and return normally. It is good practice to set the error cause when wrapping a thrown error.","url":"././~/ErrorHandler.html","deprecated":false},{"id":"namespace_ExitCodeError","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"ExitCodeError","file":".","doc":"Thrown because the process returned an exit code that indicates an error occurred. By default, this indicates a non-zero exit code but may be overridden.","url":"././~/ExitCodeError.html","deprecated":false},{"id":"namespace_HOURS","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"HOURS","file":".","doc":"The number of milliseconds in an hour.","url":"././~/HOURS.html","deprecated":false},{"id":"namespace_Lines","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Lines","file":".","doc":"Conditional type for Enumerable.lines.","url":"././~/Lines.html","deprecated":false},{"id":"namespace_MINUTES","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"MINUTES","file":".","doc":"The number of milliseconds in a minute.","url":"././~/MINUTES.html","deprecated":false},{"id":"namespace_PipeKinds","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"PipeKinds","file":".","doc":"Pipe kinds, matching Deno.Command.","url":"././~/PipeKinds.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"Process","file":".","doc":"Wrapper for Deno.ChildProcess with enhanced error handling and stream management.This class provides a lower-level interface than run. It converts streams to AsyncIterables, handles errors properly, and manages resource cleanup automatically.Most users should use run instead, which provides a simpler, more composable API. Use Process directly only when you need fine-grained control over process lifecycle.Why this is better than Deno.Command:Automatic resource cleanup (no leaked processes)Proper error propagation from stderrAsyncIterable streams (easier to work with)Custom error handlersBuffered input option for performance","url":"././~/Process.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.isClosed","file":".","doc":"Indicates close has been called.","url":"././~/Process.prototype.isClosed.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.close","file":".","doc":"Do all necessary normal steps to close the process. This does not kill the process but attempts a normal close.","url":"././~/Process.prototype.close.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.pid","file":".","doc":"Process PID.","url":"././~/Process.prototype.pid.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.status","file":".","doc":"Process status.","url":"././~/Process.prototype.status.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.stderr","file":".","doc":"stderr of the process.","url":"././~/Process.prototype.stderr.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.stdout","file":".","doc":"stdout of the process.","url":"././~/Process.prototype.stdout.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.stdin","file":".","doc":"stdin as a WritableIterable.This property is here to make the interface philosophically compatible with stdin of the wrapped process, but uses a mechanism that JavaScript does not optimize very well. Recommend using writeToStdin instead if that is possible.","url":"././~/Process.prototype.stdin.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Process.prototype.writeToStdin","file":".","doc":"This is the \"backdoor\" way to write directly to the underlying process stdin without the overhead of a WritableIterable. Use instead of stdin for streamed data.stdin is the way to go if you are passing ad-hoc, non-continuous data to process stdin. However, it adds a substantial amount of overhead, and it is very slow for processing small data. Using this function instead of stdin greatly improves performance where small data is a factor.","url":"././~/Process.prototype.writeToStdin.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype.id","file":".","doc":"","url":"././~/Process.prototype.id.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype.stderrResult","file":".","doc":"","url":"././~/Process.prototype.stderrResult.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype.process","file":".","doc":"The wrapped process.","url":"././~/Process.prototype.process.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype._stderr","file":".","doc":"","url":"././~/Process.prototype._stderr.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype._stdout","file":".","doc":"","url":"././~/Process.prototype._stdout.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype._stdin","file":".","doc":"","url":"././~/Process.prototype._stdin.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype._isClosed","file":".","doc":"","url":"././~/Process.prototype._isClosed.html","deprecated":false},{"id":"namespace_Process","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Process.prototype._passError","file":".","doc":"","url":"././~/Process.prototype._passError.html","deprecated":false},{"id":"namespace_ProcessEnumerable","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"ProcessEnumerable","file":".","doc":"Enumerable for process output with additional process-specific properties.Extends Enumerable with process management capabilities. Use .lines property to get line-based output, or iterate over raw bytes.Important: Always consume the process output (via .lines.collect(), .lines.forEach(), etc.) or the process will leak resources.Error Handling: Processes that exit with non-zero codes throw ExitCodeError when you consume their output. Wrap in try-catch to handle.","url":"././~/ProcessEnumerable.html","deprecated":false},{"id":"namespace_ProcessEnumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"ProcessEnumerable.prototype.pid","file":".","doc":"Process PID.","url":"././~/ProcessEnumerable.prototype.pid.html","deprecated":false},{"id":"namespace_ProcessEnumerable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"ProcessEnumerable.prototype.status","file":".","doc":"Process exit status.Important: This is a property that returns a Promise, not a method. Use await p.status not await p.status().The Promise resolves when the process exits. You should consume the process output before or concurrently with checking status to avoid resource leaks.","url":"././~/ProcessEnumerable.prototype.status.html","deprecated":false},{"id":"namespace_ProcessError","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"ProcessError","file":".","doc":"A generic process error.","url":"././~/ProcessError.html","deprecated":false},{"id":"namespace_ProcessOptions","kind":[{"char":"I","kind":"Interface","title":"Interface"}],"name":"ProcessOptions","file":".","doc":"Options passed to a process.","url":"././~/ProcessOptions.html","deprecated":false},{"id":"namespace_ProcessOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessOptions.cwd","file":".","doc":"Current working directory.","url":"././~/ProcessOptions.cwd.html","deprecated":false},{"id":"namespace_ProcessOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessOptions.env","file":".","doc":"Environment variables.","url":"././~/ProcessOptions.env.html","deprecated":false},{"id":"namespace_ProcessOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessOptions.fnStderr","file":".","doc":"Optionally process all lines of stderr.","url":"././~/ProcessOptions.fnStderr.html","deprecated":false},{"id":"namespace_ProcessOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessOptions.fnError","file":".","doc":"Optionally override error handling.","url":"././~/ProcessOptions.fnError.html","deprecated":false},{"id":"namespace_ProcessOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessOptions.buffer","file":".","doc":"Turn on input buffering.Buffering input can improve performance in some cases, but it can also change behavior in subtle ways - in particular if you are expecting a process to respond immediately to written input on an open stream. To prevent confusion, buffering is turned off by default.","url":"././~/ProcessOptions.buffer.html","deprecated":false},{"id":"namespace_ProcessStreamOptions","kind":[{"char":"I","kind":"Interface","title":"Interface"}],"name":"ProcessStreamOptions","file":".","doc":"Command options.","url":"././~/ProcessStreamOptions.html","deprecated":false},{"id":"namespace_ProcessStreamOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessStreamOptions.stdin","file":".","doc":"Pipe kind for stdin.","url":"././~/ProcessStreamOptions.stdin.html","deprecated":false},{"id":"namespace_ProcessStreamOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessStreamOptions.stdout","file":".","doc":"Pipe kind for stdout.","url":"././~/ProcessStreamOptions.stdout.html","deprecated":false},{"id":"namespace_ProcessStreamOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"ProcessStreamOptions.stderr","file":".","doc":"Pipekind for stderr.","url":"././~/ProcessStreamOptions.stderr.html","deprecated":false},{"id":"namespace_RangeToOptions","kind":[{"char":"I","kind":"Interface","title":"Interface"}],"name":"RangeToOptions","file":".","doc":"Options for a to range. The to range is exclusive.","url":"././~/RangeToOptions.html","deprecated":false},{"id":"namespace_RangeToOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"RangeToOptions.from","file":".","doc":"Starting number inclusive; defaults to 0.","url":"././~/RangeToOptions.from.html","deprecated":false},{"id":"namespace_RangeToOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"RangeToOptions.to","file":".","doc":"Ending number exclusinve.","url":"././~/RangeToOptions.to.html","deprecated":false},{"id":"namespace_RangeToOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"RangeToOptions.step","file":".","doc":"Step value. Defaults to 1.","url":"././~/RangeToOptions.step.html","deprecated":false},{"id":"namespace_RangeUntilOptions","kind":[{"char":"I","kind":"Interface","title":"Interface"}],"name":"RangeUntilOptions","file":".","doc":"Options for an until range. The until value is inclusive.","url":"././~/RangeUntilOptions.html","deprecated":false},{"id":"namespace_RangeUntilOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"RangeUntilOptions.from","file":".","doc":"Starting number inclusive; defaults to 0.","url":"././~/RangeUntilOptions.from.html","deprecated":false},{"id":"namespace_RangeUntilOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"RangeUntilOptions.until","file":".","doc":"Ending number inclusive.","url":"././~/RangeUntilOptions.until.html","deprecated":false},{"id":"namespace_RangeUntilOptions","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"RangeUntilOptions.step","file":".","doc":"Step value. Defaults to 1.","url":"././~/RangeUntilOptions.step.html","deprecated":false},{"id":"namespace_Run","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Run","file":".","doc":"Conditional type for Enumerable.run.","url":"././~/Run.html","deprecated":false},{"id":"namespace_SECONDS","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"SECONDS","file":".","doc":"The number of milliseconds in a second.","url":"././~/SECONDS.html","deprecated":false},{"id":"namespace_SignalError","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"SignalError","file":".","doc":"Thrown because the process exited due to a signal. By default, this is thrown for any signal but may be overridden.","url":"././~/SignalError.html","deprecated":false},{"id":"namespace_StandardData","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"StandardData","file":".","doc":"Standard data, either string, arrays of strings (lines), byte data, or arrays of byte data.","url":"././~/StandardData.html","deprecated":false},{"id":"namespace_StderrHandler","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"StderrHandler","file":".","doc":"Optionally handle lines of stderr (passed as text lines), and also optionally return a value that is passed to your custom ErrorHandler. You are not allowed to throw an error from this function. If you wish to throw an error based on stderr data, the ErrorHandler function is where you do that.","url":"././~/StderrHandler.html","deprecated":false},{"id":"namespace_TransformStream","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"TransformStream","file":".","doc":"Type alias for TransformStream used in Enumerable.transform.","url":"././~/TransformStream.html","deprecated":false},{"id":"namespace_TransformerFunction","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"TransformerFunction","file":".","doc":"Type signature of a transformer.","url":"././~/TransformerFunction.html","deprecated":false},{"id":"namespace_Unzip","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Unzip","file":".","doc":"Conditional type for Enumerable.unzip.","url":"././~/Unzip.html","deprecated":false},{"id":"namespace_UpstreamError","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"UpstreamError","file":".","doc":"Thrown to indicate an error occurred upstream and is being passed forward.","url":"././~/UpstreamError.html","deprecated":false},{"id":"namespace_WEEKS","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"WEEKS","file":".","doc":"The number of milliseconds in a week.","url":"././~/WEEKS.html","deprecated":false},{"id":"namespace_Writable","kind":[{"char":"I","kind":"Interface","title":"Interface"}],"name":"Writable","file":".","doc":"Simplified writable.","url":"././~/Writable.html","deprecated":false},{"id":"namespace_Writable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Writable.isClosed","file":".","doc":"Indicates this is closed.","url":"././~/Writable.isClosed.html","deprecated":false},{"id":"namespace_Writable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Writable.close","file":".","doc":"Close the writable.This must be called. The underlying resource will not be closed automatically.Once closed, subsequent calls to write(...) will throw an error.It is safe to call close() multiple times. Calls to close() after the first are a no-op.If an error is passed on close(), it propagates forward.The error (or undefined) passed on the first call to close() will be the one that is used. Error conditions passed on subsequent calls to close will be ignored.","url":"././~/Writable.close.html","deprecated":false},{"id":"namespace_Writable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Writable.write","file":".","doc":"Write an item.","url":"././~/Writable.write.html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"WritableIterable","file":".","doc":"Invert data flow: push writes on one side, iterate on the other.WritableIterable bridges the gap between push-based (write) and pull-based (iterate) programming models. It's useful when you need to feed data into an AsyncIterable from imperative code.Important: You must call close() when done writing, or iteration will hang.Why use this?Convert callback-based APIs to AsyncIterableFeed data to process stdin programmaticallyBridge between different async patternsProper error propagation","url":"././~/WritableIterable.html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"WritableIterable.prototype.isClosed","file":".","doc":"","url":"././~/WritableIterable.prototype.isClosed.html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"WritableIterable.prototype.addEmptyPromiseToQueue","file":".","doc":"Add an unresolved promise to the end of the queue.","url":"././~/WritableIterable.prototype.addEmptyPromiseToQueue.html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"WritableIterable.prototype.close","file":".","doc":"","url":"././~/WritableIterable.prototype.close.html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"WritableIterable.prototype.write","file":".","doc":"","url":"././~/WritableIterable.prototype.write.html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"WritableIterable.prototype.[Symbol.asyncIterator]","file":".","doc":"It is an AsyncIterable<T>.","url":"././~/WritableIterable.prototype.[Symbol.asyncIterator].html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"WritableIterable.prototype._closed","file":".","doc":"","url":"././~/WritableIterable.prototype._closed.html","deprecated":false},{"id":"namespace_WritableIterable","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"WritableIterable.prototype.queue","file":".","doc":"","url":"././~/WritableIterable.prototype.queue.html","deprecated":false},{"id":"namespace_buffer","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"buffer","file":".","doc":"Transformer that conditionally adds buffering to a Uint8Array stream.This enforces that the size of the passed data is at least size. Note that data is never reduced in size. It is either passed through unchanged (if it is big enough already) or held and concatenated with the next data until it there is enough data to write through.If size is 0 or negative, the input data is passed through without buffering.You do not normally need to use this transform directly as you can turn on input buffering with a parameter to the run method or function.","url":"././~/buffer.html","deprecated":false},{"id":"namespace_cache","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"cache","file":".","doc":"Fetch and cache expensive computations using Deno KV.Caches the result of an async function call. If the cached value exists and hasn't expired, returns it immediately. Otherwise, calls the function, caches the result, and returns it.Use cases:Cache expensive API callsStore computed results between runsReduce redundant processingImplement time-based invalidation","url":"././~/cache.html","deprecated":false},{"id":"namespace_concat","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"concat","file":".","doc":"Fast-concatenate Uint8Array arrays into a single array.Optimized to avoid unnecessary copying:Returns empty array for empty inputReturns the original array if only one element (no copy)Otherwise performs efficient concatenation","url":"././~/concat.html","deprecated":false},{"id":"namespace_concatLines","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"concatLines","file":".","doc":"Fast-concatenate Uint8Arrays arrays together, adding a trailing line feed, returning a single array containing the result.","url":"././~/concatLines.html","deprecated":false},{"id":"namespace_debug","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"debug","file":".","doc":"Debug output using console.dir through Enumerable#transform.","url":"././~/debug.html","deprecated":false},{"id":"namespace_enumerate","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"enumerate","file":".","doc":"Create an Enumerable from any iterable or async iterable.This is the factory function for creating Enumerable instances. It provides a fluent API for working with async data streams, making it easy to chain operations like map, filter, and transform.Important: This function wraps an iterable but does NOT add index counters. To add index counters, call .enum() on the returned Enumerable.Why use Enumerable?Composable operations via method chainingWorks seamlessly with async dataIntegrates with process I/OLazy evaluation for memory efficiencyType-safe transformations","url":"././~/enumerate.html","deprecated":false},{"id":"namespace_fetchRecord","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"fetchRecord","file":".","doc":"Fetch a record from KV. Use cache instead; exported for debugging.","url":"././~/fetchRecord.html","deprecated":false},{"id":"namespace_gunzip","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"gunzip","file":".","doc":"Decompress gzip-compressed data.Works with any StandardData input (strings, bytes, arrays). Useful for reading compressed files or decompressing process output.","url":"././~/gunzip.html","deprecated":false},{"id":"namespace_gzip","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"gzip","file":".","doc":"Compress data using gzip.Works with any StandardData input (strings, bytes, arrays). Useful for compressing data before writing to files or sending to processes.","url":"././~/gzip.html","deprecated":false},{"id":"namespace_isString","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"isString","file":".","doc":"Type guard to check if a value is a string.Handles both string primitives and String objects.","url":"././~/isString.html","deprecated":false},{"id":"namespace_jsonParse","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"jsonParse","file":".","doc":"Parse JSON-encoded strings into objects.Useful for deserializing JSONL (JSON Lines) format data. Each line should be a complete JSON object.","url":"././~/jsonParse.html","deprecated":false},{"id":"namespace_jsonStringify","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"jsonStringify","file":".","doc":"Convert objects to JSON-encoded strings (one per line).Useful for serializing structured data to pass between processes or save to files in JSONL (JSON Lines) format.","url":"././~/jsonStringify.html","deprecated":false},{"id":"namespace_range","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"range","file":".","doc":"Lazily generate a range of numbers as an AsyncIterable.Two forms available:to: Exclusive upper bounduntil: Inclusive upper boundSupports negative steps for counting down.","url":"././~/range.html","deprecated":false},{"id":"namespace_read","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"read","file":".","doc":"Open a file for reading as an AsyncIterable of byte chunks.Returns an Enumerable that can be transformed, piped to processes, or converted to lines. The file is automatically closed when iteration completes.","url":"././~/read.html","deprecated":false},{"id":"namespace_run","kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"run","file":".","doc":"Run a child process with a fluent, composable API.This is the primary entry point for deno-proc. Unlike Deno's built-in Deno.Command, this function returns a ProcessEnumerable (extends AsyncIterable) that makes it trivial to:Chain processes together with .run()Transform output with .map(), .filter(), etc.Parse lines with .lines propertyHandle errors gracefullyAvoid common pitfalls like deadlocks and resource leaksWhy use this instead of Deno.Command?Deno's Deno.Command requires manual stream handling, careful resource management, and verbose boilerplate. With deno-proc:No manual stream reading/writingAutomatic resource cleanupComposable operations via AsyncIterableBuilt-in line parsing and transformationsProper error propagationImportant: Error HandlingProcesses that exit with non-zero codes throw ExitCodeError when you consume their output. You must consume stdout (via .lines, .collect(), etc.) or the process will leak resources.Important: Resource ManagementAlways consume the process output or explicitly handle the stream. Unconsumed stdout will cause resource leaks. Use .lines.collect(), .lines.forEach(), or similar to consume output.","url":"././~/run.html","deprecated":false},{"id":"namespace_shuffle","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"shuffle","file":".","doc":"Performs an in-place shuffle of an array in linear time.This function uses the Fisher-Yates (also known as Knuth) shuffle algorithm to rearrange the elements in the array in a random order. The shuffle is performed in-place, meaning that it modifies the original array instead of creating a new one. The time complexity of the algorithm is O(n), where n is the number of elements in the array.","url":"././~/shuffle.html","deprecated":false},{"id":"namespace_sleep","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"sleep","file":".","doc":"The sleep function is used to pause the execution of the program for a specified amount of time. It returns a Promise that resolves after a set number of milliseconds, effectively causing a delay in the execution of the subsequent code.","url":"././~/sleep.html","deprecated":false},{"id":"namespace_toBufferSource","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"toBufferSource","file":".","doc":"For transformers that need BufferSource as input, this will convert the type of the output; otherwise identical to toBytes.This is needed for working directly with CompressionStream and DecompressionStream.","url":"././~/toBufferSource.html","deprecated":false},{"id":"namespace_toByteLines","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"toByteLines","file":".","doc":"Convert an AsyncIterable<Uint8Array> into an AsyncIterable<Uint8Array[]> (an array of lines chunked together based on buffer size) split on lf and also suppressing trailing cr.lf and trailing cr is removed from the returned lines. As this is line-oriented data, if the last line is empty (the last byte was a line feed, splitting into one extra line), it is suppressed.Implementation attempts to minimize object creation.","url":"././~/toByteLines.html","deprecated":false},{"id":"namespace_toBytes","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"toBytes","file":".","doc":"Convert strings, string arrays, or byte arrays to Uint8Array chunks.Conversion rules:string: Converted to UTF-8 bytes with trailing newlinestring[]: Each string converted to UTF-8 with newline, concatenatedUint8Array: Passed through unchangedUint8Array[]: Concatenated into single arrayStrings are always treated as lines (newline added). Bytes are treated as binary data.","url":"././~/toBytes.html","deprecated":false},{"id":"namespace_toChunkedLines","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"toChunkedLines","file":".","doc":"Convert an AsyncIterable<Uint8Array> into an AsyncIterable<string[]> of lines.For larger data sets and very small lines (like broken into one word per line), using this helps keep the data being passed at reasonable sizes and avoids the \"small string\" problem. Consider using this instead of toLines in that case.","url":"././~/toChunkedLines.html","deprecated":false},{"id":"namespace_toLines","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"toLines","file":".","doc":"Convert an AsyncIterable<Uint8Array> into an AsyncIterable<string> of lines.","url":"././~/toLines.html","deprecated":false},{"id":"namespace_transformerFromTransformStream","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"transformerFromTransformStream","file":".","doc":"Convert a TransformStream into a TransformerFunction. Errors occurring upstream are correctly propagated through the transformation.","url":"././~/transformerFromTransformStream.html","deprecated":false},{"id":"namespace_writeAll","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"writeAll","file":".","doc":"Low level write without locking, writing in multiple chunks if needed.Data is written completely. Does not attempt to close the writer.","url":"././~/writeAll.html","deprecated":false}]};
})()